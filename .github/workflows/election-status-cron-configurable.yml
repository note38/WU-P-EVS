name: Election Status Auto Update (Configurable)

on:
  schedule:
    # Default: Every 5 minutes (more reasonable for production)
    - cron: "*/5 * * * *"

    # Alternative schedules (uncomment as needed):
    # - cron: '* * * * *'        # Every minute (high frequency)
    # - cron: '*/2 * * * *'      # Every 2 minutes
    # - cron: '*/10 * * * *'     # Every 10 minutes
    # - cron: '*/15 * * * *'     # Every 15 minutes
    # - cron: '*/30 * * * *'     # Every 30 minutes
    # - cron: '0 * * * *'        # Every hour

  # Allow manual triggering with options
  workflow_dispatch:
    inputs:
      frequency:
        description: "Trigger frequency"
        required: false
        default: "single"
        type: choice
        options:
          - single
          - test-5-times
      reason:
        description: "Reason for manual trigger"
        required: false
        default: "Manual trigger"

env:
  # Workflow configuration
  MAX_RETRIES: 3
  RETRY_DELAY: 10

jobs:
  update-election-status:
    runs-on: ubuntu-latest

    steps:
      - name: Setup Job Info
        run: |
          echo "üîß Job Configuration:"
          echo "  - Trigger: ${{ github.event_name }}"
          echo "  - Time: $(date)"
          echo "  - Repository: ${{ github.repository }}"
          echo "  - Workflow: ${{ github.workflow }}"

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "  - Manual frequency: ${{ github.event.inputs.frequency }}"
            echo "  - Reason: ${{ github.event.inputs.reason }}"
          fi

      - name: Validate Secrets
        run: |
          echo "üîê Validating required secrets..."

          # Validate required secrets are set
          if [ -z "${{ secrets.DEPLOYMENT_URL }}" ]; then
            echo "‚ùå DEPLOYMENT_URL secret is not set"
            echo "üí° Please set the DEPLOYMENT_URL secret in GitHub repository settings"
            echo "üìù Current value: '${{ secrets.DEPLOYMENT_URL }}'"
            exit 1
          fi

          if [ -z "${{ secrets.CRON_SECRET }}" ]; then
            echo "‚ùå CRON_SECRET secret is not set"
            echo "üí° Please set the CRON_SECRET secret in GitHub repository settings"
            exit 1
          fi

          echo "‚úÖ All required secrets are set"

      - name: Call Election Status Endpoint (Single)
        if: github.event_name == 'schedule' || github.event.inputs.frequency == 'single'
        run: |
          echo "üöÄ Triggering single election status update..."

          # Construct the full URL
          BASE_URL="${{ secrets.DEPLOYMENT_URL }}"
          # Remove trailing slash if present
          BASE_URL="${BASE_URL%/}"
          ENDPOINT="$BASE_URL/api/cron/election-status"

          echo "üì° Calling endpoint: $ENDPOINT"
          echo "üîê Using CRON_SECRET: ${{ secrets.CRON_SECRET }}"

          # Function to make the API call
          make_request() {
            local attempt=$1
            echo "üì° Attempt $attempt/$MAX_RETRIES"
            
            # Make request to the cron endpoint with verbose output for debugging
            echo "üîç Making request with curl..."
            response=$(curl -v -s -w "\nHTTP_STATUS:%{http_code}\nTOTAL_TIME:%{time_total}\nCONNECT_TIME:%{time_connect}\nHTTP_CODE:%{http_code}" \
              -H "Authorization: Bearer ${{ secrets.CRON_SECRET }}" \
              -H "Content-Type: application/json" \
              -H "User-Agent: github-actions-cron/1.0" \
              -X GET \
              "$ENDPOINT" 2>&1)
            
            # Extract timing information
            total_time=$(echo "$response" | grep "TOTAL_TIME:" | sed 's/TOTAL_TIME://')
            connect_time=$(echo "$response" | grep "CONNECT_TIME:" | sed 's/CONNECT_TIME://')
            http_code=$(echo "$response" | grep "HTTP_CODE:" | sed 's/HTTP_CODE://')
            
            echo "‚è±Ô∏è  Connection time: ${connect_time}s"
            echo "‚è±Ô∏è  Total time: ${total_time}s"
            echo "üìä Response Status: $http_code"
            
            # Extract HTTP status and response body
            http_status=$(echo "$response" | grep "HTTP_STATUS:" | sed 's/HTTP_STATUS://')
            response_body=$(echo "$response" | sed -n '/HTTP_STATUS:/q;p' | sed '/^*/d' | sed '/^>/d' | sed '/^</d' | sed '/^}/d' | sed '/^$/d' | head -n -3 | tail -n +2)
            
            echo "üìÑ Response Body: $response_body"
            
            # If we still get 000, show the full response for debugging
            if [ "$http_status" = "000" ]; then
              echo "üîç Detailed curl output for debugging:"
              echo "$response"
            fi
            
            if [ "$http_status" -eq 200 ]; then
              echo "‚úÖ Request successful"
              
              # Parse and display results
              updated_count=$(echo "$response_body" | jq -r '.updatedCount // 0' 2>/dev/null || echo "0")
              message=$(echo "$response_body" | jq -r '.message // "Status check completed"' 2>/dev/null || echo "Status check completed")
              
              echo "üìà Updated elections: $updated_count"
              echo "üí¨ Message: $message"
              
              if [ "$updated_count" -gt 0 ]; then
                echo "üó≥Ô∏è Updated Elections:"
                echo "$response_body" | jq -r '.updatedElections[]? | "  - \(.name) (ID: \(.id)) ‚Üí \(.status)"' 2>/dev/null || echo "  - Details not available"
              fi
              
              return 0
            else
              echo "‚ùå Request failed with status: $http_status"
              echo "üí• Response: $response_body"
              return 1
            fi
          }

          # Retry logic
          for i in $(seq 1 $MAX_RETRIES); do
            if make_request $i; then
              echo "üéØ Success on attempt $i"
              break
            elif [ $i -lt $MAX_RETRIES ]; then
              echo "‚è≥ Waiting ${RETRY_DELAY}s before retry..."
              sleep $RETRY_DELAY
            else
              echo "üíÄ All $MAX_RETRIES attempts failed"
              # Only exit with error for server errors, not client errors
              if [ "$http_status" -ge 500 ] || [ "$http_status" = "000" ]; then
                exit 1
              fi
              break
            fi
          done

      - name: Call Election Status Endpoint (Test Multiple)
        if: github.event.inputs.frequency == 'test-5-times'
        run: |
          echo "üß™ Running test with 5 requests (30-second intervals)..."

          # Construct the full URL
          BASE_URL="${{ secrets.DEPLOYMENT_URL }}"
          # Remove trailing slash if present
          BASE_URL="${BASE_URL%/}"
          ENDPOINT="$BASE_URL/api/cron/election-status"

          echo "üì° Calling endpoint: $ENDPOINT"

          for i in {1..5}; do
            echo ""
            echo "üîÑ Test Request $i/5 at $(date)"
            
            response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
              -H "Authorization: Bearer ${{ secrets.CRON_SECRET }}" \
              -H "Content-Type: application/json" \
              -H "User-Agent: github-actions-cron-test/1.0" \
              "$ENDPOINT")
            
            http_status=$(echo "$response" | tail -n1 | sed 's/HTTP_STATUS://')
            response_body=$(echo "$response" | sed '$d')
            
            echo "üìä Status: $http_status"
            if [ "$http_status" -eq 200 ]; then
              updated_count=$(echo "$response_body" | jq -r '.updatedCount // 0' 2>/dev/null || echo "0")
              echo "üìà Updates: $updated_count"
              echo "‚úÖ Success"
            else
              echo "‚ùå Failed"
              echo "üí• Error: $response_body"
            fi
            
            # Wait 30 seconds between requests (except for last one)
            if [ $i -lt 5 ]; then
              echo "‚è≥ Waiting 30 seconds..."
              sleep 30
            fi
          done

      - name: Summary
        if: always()
        run: |
          echo ""
          echo "üìã Execution Summary:"
          echo "  - Workflow: ${{ github.workflow }}"
          echo "  - Trigger: ${{ github.event_name }}"
          echo "  - Completed: $(date)"
          echo "  - Status: ${{ job.status }}"

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "  - Manual trigger reason: ${{ github.event.inputs.reason }}"
          fi

          echo ""
          echo "üîó Useful Links:"
          echo "  - Workflow runs: https://github.com/${{ github.repository }}/actions"
          echo "  - Vercel dashboard: https://vercel.com/dashboard"
          echo "  - Application: ${{ secrets.DEPLOYMENT_URL }}"
