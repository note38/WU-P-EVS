name: Election Status Auto Update

on:
  schedule:
    # Run every minute as requested
    - cron: "* * * * *"

  # Allow manual triggering
  workflow_dispatch:
    inputs:
      reason:
        description: "Reason for manual trigger"
        required: false
        default: "Manual trigger"

jobs:
  update-election-status:
    runs-on: ubuntu-latest

    steps:
      - name: Call Election Status Cron Endpoint
        run: |
          echo "ğŸš€ Triggering election status update..."
          echo "â° Current time: $(date)"

          # Validate required secrets are set
          if [ -z "${{ secrets.DEPLOYMENT_URL }}" ]; then
            echo "âŒ DEPLOYMENT_URL secret is not set"
            echo "ğŸ’¡ Please set the DEPLOYMENT_URL secret in GitHub repository settings"
            echo "ğŸ“ Current value: '${{ secrets.DEPLOYMENT_URL }}'"
            exit 1
          fi

          if [ -z "${{ secrets.CRON_SECRET }}" ]; then
            echo "âŒ CRON_SECRET secret is not set"
            echo "ğŸ’¡ Please set the CRON_SECRET secret in GitHub repository settings"
            exit 1
          fi

          # Construct the full URL
          BASE_URL="${{ secrets.DEPLOYMENT_URL }}"
          # Remove trailing slash if present
          BASE_URL="${BASE_URL%/}"
          ENDPOINT="$BASE_URL/api/cron/election-status"

          echo "ğŸ“¡ Calling endpoint: $ENDPOINT"
          echo "ğŸ” Using CRON_SECRET: ${{ secrets.CRON_SECRET }}"

          # Make request to the cron endpoint with verbose output for debugging
          echo "ğŸ” Making request with curl..."
          response=$(curl -v -s -w "\nHTTP_STATUS:%{http_code}\nTOTAL_TIME:%{time_total}\nCONNECT_TIME:%{time_connect}\nHTTP_CODE:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.CRON_SECRET }}" \
            -H "Content-Type: application/json" \
            -H "User-Agent: github-actions-cron/1.0" \
            "$ENDPOINT" 2>&1)

          # Extract timing information
          total_time=$(echo "$response" | grep "TOTAL_TIME:" | sed 's/TOTAL_TIME://')
          connect_time=$(echo "$response" | grep "CONNECT_TIME:" | sed 's/CONNECT_TIME://')
          http_code=$(echo "$response" | grep "HTTP_CODE:" | sed 's/HTTP_CODE://')

          echo "â±ï¸  Connection time: ${connect_time}s"
          echo "â±ï¸  Total time: ${total_time}s"
          echo "ğŸ“Š Response Status: $http_code"

          # Extract HTTP status and response body
          http_status=$(echo "$response" | grep "HTTP_STATUS:" | sed 's/HTTP_STATUS://')
          response_body=$(echo "$response" | sed -n '/HTTP_STATUS:/q;p' | sed '/^*/d' | sed '/^>/d' | sed '/^</d' | sed '/^}/d' | sed '/^$/d' | head -n -3 | tail -n +2)

          echo "ğŸ“„ Response Body: $response_body"

          # If we still get 000, show the full response for debugging
          if [ "$http_status" = "000" ]; then
            echo "ğŸ” Detailed curl output for debugging:"
            echo "$response"
          fi

          # Check if request was successful
          if [ "$http_status" -eq 200 ]; then
            echo "âœ… Election status update completed successfully"
            
            # Parse and display update information
            updated_count=$(echo "$response_body" | jq -r '.updatedCount // 0' 2>/dev/null || echo "0")
            message=$(echo "$response_body" | jq -r '.message // "Status check completed"' 2>/dev/null || echo "Status check completed")
            
            echo "ğŸ“ˆ Updated elections: $updated_count"
            echo "ğŸ’¬ Message: $message"
            
            # Display updated elections if any
            if [ "$updated_count" -gt 0 ]; then
              echo "ğŸ—³ï¸ Updated Elections:"
              echo "$response_body" | jq -r '.updatedElections[]? | "  - \(.name) (ID: \(.id)) â†’ \(.status)"' 2>/dev/null || echo "  - Details not available"
            fi
          else
            echo "âŒ Election status update failed with status: $http_status"
            echo "ğŸ’¥ Error response: $response_body"
            # Only exit with error for server errors, not client errors
            if [ "$http_status" -ge 500 ] || [ "$http_status" = "000" ]; then
              exit 1
            fi
          fi

      - name: Log Completion
        if: always()
        run: |
          echo "ğŸ Election status cron job completed at $(date)"
          echo "ğŸ“‹ Workflow triggered by: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "ğŸ“ Manual trigger reason: ${{ github.event.inputs.reason }}"
          fi
